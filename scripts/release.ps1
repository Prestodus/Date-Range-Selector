param(
  [ValidateSet('major','minor','patch')]
  [string]$Type = 'patch',
  [string]$Message = '',
  [switch]$AutoMerge
)

function Abort([string]$msg) {
  Write-Error $msg
  exit 1
}

Write-Host "Starting release script (type=$Type)"

# Ensure tools
if (-not (Get-Command git -ErrorAction SilentlyContinue)) { Abort 'git required' }
if (-not (Get-Command npm -ErrorAction SilentlyContinue)) { Abort 'npm required' }
if (-not (Get-Command gh -ErrorAction SilentlyContinue)) { Write-Warning 'gh CLI not found; PR/Release steps will need manual steps' }

# Save current state
$status = (git status --porcelain)
$stashed = $false
if ($status -ne '') {
  Write-Host 'Working tree not clean; stashing changes...' -ForegroundColor Yellow
  git stash push -u -m "release-stash-$(Get-Date -Format o)" | Out-Null
  if ($LASTEXITCODE -ne 0) { Abort 'Failed to stash changes' }
  $stashed = $true
}

Write-Host 'Installing dependencies...' -ForegroundColor Cyan
npm ci
if ($LASTEXITCODE -ne 0) { Abort 'npm ci failed' }

Write-Host 'Building to validate...' -ForegroundColor Cyan
npx tsc --noEmit
if ($LASTEXITCODE -ne 0) { Abort 'Typecheck failed' }
npm run build
if ($LASTEXITCODE -ne 0) { Abort 'Build failed' }

# Read and bump package.json
$pkgPath = Join-Path (Get-Location) 'package.json'
try {
  $pkg = Get-Content -LiteralPath $pkgPath -Raw | ConvertFrom-Json
} catch {
  Abort "Failed to read package.json: $($_.Exception.Message)"
}
$current = $pkg.version
Write-Host "Current version: $current"

function Bump-Version([string]$ver, [string]$type) {
  $parts = $ver.Split('.') | ForEach-Object {[int]$_}
  switch ($type) {
    'patch' { $parts[2] += 1 }
    'minor' { $parts[1] += 1; $parts[2] = 0 }
    'major' { $parts[0] += 1; $parts[1] = 0; $parts[2] = 0 }
  }
  return "$($parts[0]).$($parts[1]).$($parts[2])"
}

$next = Bump-Version $current $Type
Write-Host "Next version: $next"

try {
  $pkg.version = $next
  $out = $pkg | ConvertTo-Json -Depth 10
  [System.IO.File]::WriteAllText($pkgPath, $out, (New-Object System.Text.UTF8Encoding($false)))
} catch {
  Abort "Failed to write package.json: $($_.Exception.Message)"
}

# Update source VERSION constant
function Update-SourceVersion {
  param([Parameter(Mandatory=$true)][string]$Version)
  $srcRel = '..\src\date-range-selector-card.ts'
  $src = Resolve-Path -LiteralPath (Join-Path $PSScriptRoot $srcRel) -ErrorAction SilentlyContinue
  if (-not $src) { Write-Warning "Source file not found: $srcRel"; return $false }
  $srcPath = $src.Path
  $content = Get-Content -LiteralPath $srcPath -Raw -Encoding UTF8

  # Regex to match: const VERSION = 'v1.2.3'; or "v1.2.3"
  $pattern = 'const\s+VERSION\s*=\s*[''\"]v?\d+\.\d+\.\d+[''\"];'
  $replacement = "const VERSION = 'v$Version';"

  if ([System.Text.RegularExpressions.Regex]::IsMatch($content, $pattern)) {
    $new = [System.Text.RegularExpressions.Regex]::Replace($content, $pattern, $replacement)
  } else {
    # insert after imports block if VERSION is not found
    $insertionPoint = [System.Text.RegularExpressions.Regex]::Match(
      $content,
      '(import\s.+;\s*)+',
      [System.Text.RegularExpressions.RegexOptions]::Singleline
    )
    if ($insertionPoint.Success) {
      $idx = $insertionPoint.Index + $insertionPoint.Length
      $new = $content.Substring(0, $idx) + "`n$replacement`n" + $content.Substring($idx)
    } else {
      $new = "$replacement`n`n$content"
    }
  }

  if ($new -ne $content) {
    [System.IO.File]::WriteAllText($srcPath, $new, (New-Object System.Text.UTF8Encoding($false)))
    Write-Host "Updated $srcPath to version v$Version"
    return $true
  }

  Write-Host "$srcPath already at v$Version"
  return $false
}

# Create release branch
$branch = "release/v$next"
git checkout -b $branch
if ($LASTEXITCODE -ne 0) { Abort 'Failed to create branch' }

git add package.json

$updated = Update-SourceVersion -Version $next
if ($updated) { git add src/date-range-selector-card.ts }

git commit -m "chore(release): bump version to v$next"
if ($LASTEXITCODE -ne 0) { Abort 'Commit failed' }

git push -u origin $branch
if ($LASTEXITCODE -ne 0) { Abort 'Failed to push branch' }

# Create PR
if (Get-Command gh -ErrorAction SilentlyContinue) {
  $title = "chore(release): v$next"
  if ([string]::IsNullOrWhiteSpace($Message)) { $body = "Release v$next`n`nGenerated by release script." } else { $body = $Message }
  gh pr create --title $title --body $body --base main
  if ($LASTEXITCODE -ne 0) { Write-Warning 'gh pr create failed' }
  if ($AutoMerge.IsPresent) {
    Write-Host 'Attempting auto-merge...'
    $pr = gh pr list --head $branch --json number -q '.[0].number' 2>$null
    if ($pr) { gh pr merge $pr --squash --delete-branch; if ($LASTEXITCODE -ne 0) { Write-Warning 'Auto-merge failed' } }
    else { Write-Warning 'Could not find PR to auto-merge' }
  }
} else {
  Write-Warning 'gh not available; create PR manually'
}

# Ensure main up to date
git checkout main
if ($LASTEXITCODE -ne 0) { Abort 'Failed to checkout main' }
git pull origin main
if ($LASTEXITCODE -ne 0) { Abort 'Failed to pull main' }

# Tag
git tag -a "v$next" -m "v$next - release"
git push origin "v$next"
if ($LASTEXITCODE -ne 0) { Abort 'Failed to push tag' }

# Build and create release assets
npm ci
npm run build

if (Get-Command gh -ErrorAction SilentlyContinue) {
  $originUrl = git remote get-url origin
  if ($originUrl -match '[:\/](?<owner>[^\/]+)\/(?<repo>[^\.]+)(?:\.git)?$') { $owner=$matches['owner']; $repo=$matches['repo']; $fullRepo="$owner/$repo" } else { $fullRepo='Prestodus/Date-Range-Selector' }
  $distFiles = @('dist/date-range-selector-card.js','dist/popup-wrapper-card.js') | Where-Object { Test-Path $_ }
  if ($distFiles.Count -gt 0) {
    gh release create "v$next" $distFiles --title "v$next - release" --notes $body --repo $fullRepo
    if ($LASTEXITCODE -ne 0) { Write-Warning 'gh release create failed' }
  } else { Write-Warning 'No dist files found to upload' }
} else { Write-Warning 'gh CLI not available; create Release manually' }

# Restore stash
if ($stashed) {
  Write-Host 'Restoring stashed changes...'
  git stash pop
  if ($LASTEXITCODE -ne 0) {
    Write-Warning 'Failed to pop stash; please recover manually'
  }
}

Write-Host "Release completed: v$next" -ForegroundColor Green
